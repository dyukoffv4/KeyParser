# Light KeyParser - Тестовая облегченная версия фрейсворка KeyParser

## **Содержание**

    1. Общие сведения
    2. Использование
      2.1 Сборка и подключение динамической библиотеки
      2.2 Использование и функционал фреймворка
    3. Тестирование

---
## **1. Общие сведения**
Фреймворк *LightKeyParser* позволяет настроить пользователю критерии для парсинга аргументов программы.

Данный тестовый вариант не иммеет функционала для подключения функций - обработчиков для настроенных ключей.
На данный момент он способен, проанализировать входящие аргументы и организовать их в структуру, где будет указан ключ, его аргументы, а также порядок вызова ключей.

На данный момент проект собирается исключительно в .so библиотеку и .deb пакет.

---
## **2. Использование**

### **2.1. Сборка и подключение динамической библиотеки**

Для работы с содержимым проекта был создан bash-скрипт `controller`.
Для сборки `.deb` пакета следует запустить скрипт с командой `build`. Созданный пакет будет находится в директории "out".
Для удаления бинарных файлов и промежуточных файлов следует запустить скрипт с командой `clean`.

    KeyParser$ bash controller build
    KeyParser$ bash controller clean

### **2.2. Использование и функционал фреймворка**
Для использования элементов *KeyParser* нужно подключить заголовочный файл `terminal.hpp`:

    #include <lkeyparser/parser.hpp>

Все элементы Фреймворка расположены в пространстве имен `keyparser`. Используется класс `Parser`. Ключи содержатся в виде объектов класса `Key`.

**`Key`** - класс, который хранит информацию о ключе и имеет необходимый функционал для его использовании в `Parser`. Ниже представлен список методов и структур:

**Структуры:**
* *enum zoneState{LW, IN, HG}* - Перечисления отношений чисел по отношению к диапозону ключа.

**Конструкторы:**
* *explicit Key(const char& s_data, int f_num = -1, int s_num = -1)* - Конструктор для задания ключа с коротким именем.
* *explicit Key(const std::string& l_data, int f_num = -1, int s_num = -1)* - Конструктор для задания ключа с длинным именем.
* *explicit Key(const char& s_data, const std::string& l_data, int f_num = -1, int s_num = -1)* - Конструктор для задания ключа с полным именем.

*Опционально можно задать диапазон числа параметров (`num` и `hnum`). По умолчанию будут браться все возможные параметры, если указан только первый параметр диапазон будет взят от 0 до первого параметра*

**Методы:**
* *bool operator==(const Key& key) const* - Оператор равенства ключей.
* *zoneState operator[](const int& num) const* - Оператор определения попадания значения в диапазон параметров ключа: LW - меньше диапазона, IN - внутри диапазона, HG - больше диапазона.
* *char sname() const* - Метод для получения короткого имени ключа.
* *std::string lname() const* - Метод для получения длинного имени ключа.
* *std::string fname() const* - Метод для получения полного имени ключа.

**`Parser`** - класс, который занимается разбором поступающих параметров и их обработкой в соответствии с настройкой соответствующих ключей. Ниже представлен список методов и структур:

**Конструкторы:**
* *Parser()* - Стандартный конструктор.

**Методы:**
* *Parser& operator=(const Parser& term)* - Оператор присваивания Терминала. 
* *void addKey(const char& s_data, int f_num = -1, int s_num = -1)* - Метод для добавления ключа с коротким именем.
* *void addKey(const std::string& l_data, int f_num = -1, int s_num = -1)* - Метод для добавления ключа с длинным именем.
* *void addKey(const char& s_data, const std::string& l_data, int f_num = -1, int s_num = -1)* - Метод для добавления ключа с полным именем.
* *void delKey(const T& data)* - Шаблонный метод для удаления указанного ключа (принимает короткое или длинное имя ключа).
* *Key getKey(const T& data)* - Шаблонный метод для получения копии указанного ключа (принимает короткое или длинное имя ключа).
* *void setupRoot(int f_num, int s_num)* - Установка диапазона числа параметров для корневых параметров.
* *void parse(int argc, char\* argv[])* - Метод для обработки переданных параметров и исполнения функций-обработчиков над ними. Принимает на вход аргументы функции `main`. Игнорирует первый параметр (имя исполняемого файла).
* *void parse(Args input)* - Метод для обработки переданных параметров и исполнения функций-обработчиков над ними. Принимает на вход вектор параметров (строк).

---
## **3. Тестирование**

Тестовые функции располагаются в директории "test/src". Для их сборки предусмотрен Makefile. Пример сборки и запуска тестов:

    KeyParser$ make -C test/
    KeyParser$ test/out/libtest

Тесты для исполнения записываются в файл "test/src/main.cpp", в функцию `main()`. При необходимости можно отредактировать файл "test/src/main.cpp", добавить новые тестовые файлы и добавить зависимости в Makefile.
